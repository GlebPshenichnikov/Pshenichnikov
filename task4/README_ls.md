Пшеничников Глеб, 212 

### TASK4(ls)

Программа использует функции из библиотек   
_#include <stdio.h>  
#include <stdlib.h>  
#include <dirent.h>  
#include <sys/types.h>    
#include <string.h>  
#include <unistd.h>  
#include <sys/stat.h>  
#include <sys/stat.h>  
#include <grp.h>  
#include <pwd.h>  
#include <time.h>_

В программе описаны слудующие функции:
* `_char* name()_ `  
возвращает имя директория в котором находимся (аналог функции pwd)

* `char **ls(int *k, DIR *dr)`    
возвращает список `char **lst` из имен файлов/каталгов, которые находятся в директории, из которого была запущена программа.  
Алгоритм следующий: читаем в переменную `struct dirent *drnt` информацию об очередном файле/каталоге (используя функцию readdir(DIR *dr)) и заносим в массив `char **lst` имя файла/каталога при помощи обращения к полю структуры _d_name_; когда файлы/каталоги в нашем директории закончатся (то есть перемаенная `struct dirent *drnt` получит значение NULL) цикл прекратится. Затем добавляем в конец массива элемент NULL и возвращаем массив. 

* `void prt(char **lst, int n)`  
печатает список из имен файлов/каталогов


* `void lsr(DIR *dr)`  
печатает имена файлов/каталогов из подкаталогов текущего директория.  
Алгоритм следующий: печатаем путь к файлу/каталогу, к которому сейчас обратились (выводим переменную `char *hod`, в которой хранится строка, содержащая путь к рассматриваемому файлу/каталогу), затем создаем локальный список `char **lst` добавлниея в него файлов/каталогов, рассматриваемого каталога (получается рекурсия). Затем заполняем этот локальный список и печатаем его элементы. Потом идем по элемантам локального массива и, если получилось сменить директорию (то есть функция _chdir(char* buf)_ дала нулевое значение), запоминаем текущий `hod`, изменяем его под новый директорий, открываем новый директирий и вызываем  `void lsr(DIR *dr)`  - рекурсия. Конец рекусрсивного спуска будет, когда в директрироо не будет ни одного каталога. При возвращении из рекурсии будем возвращать значение `hod` и переходить в директорий, в которои находились до вызова рекурсии (для этого мы заранее запомниили в `char *med` имя директория, в который надо будет вернуться).

* `void display_file_type ( int st_mode )`  
определяет и выводит тип файла (при помощи поля _st_mode_ стуктуры _struct stat _, содержащей информацию о файле)

* `void display_permission ( int st_mode )`  
определяет и выводит права доступа к файлу

* `void lsl(char** lst, int n, int x)`
определяет и выводи информаию о файлах, содержащихся в директории
 
* `void rl(DIR *dr)`  
работает так же, как и lsr, только вместо вывода имен файлов - вводим информацию о нем (через функция lsl(), c флагов -l)

* `void lg(DIR *dr)`  
работает так же, как и lsr, только вместо вывода имен файлов - вводим информацию о нем (через функция lsl(), c флагов -g)
 

Общая программа делает:
1) Определяем флаги (если они есть)
2) Исходя из флагов вызываем функции
* нет флага - ls()
* '-R' - lsr()
* '-l' - lsl() c флагов l
* '-g' - lsl() c флагов g
* '-g' '-R' - lg()
* '-l' '-R' - rl()



#### ЗАПУСК
Для компиляции файла используется _Makefile_.  
Для запуска прогаммы надо написать в консоль _make task4, произойдет компиляция программы. Далее пишем в консоль _./ls [flags]_,  программа запуститсяю  
Для котнтроля утечки памяти, запускаем программу при помощи _sudo leaks -atExit -- ./ls [flags]_
